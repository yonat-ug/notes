


[git codeschool entry:]

	git init									to initialize a git repository 
	git status									current state of the project
	git add octocat.txt								add new/modified file to staging area
	git commit -m "Add cute octocat story"						store staged changes
	git add '*.txt'									add all .txt files to staging area
	git log										log
	git remote add origin https://github.com/try-git/try_git.git			add new/modified file to remote staging area
	git push -u origin master							"-u" saves defaults: [name of remote] = origin, [default branch] = master
	git push									acts regarding "git push -u origin master"							 
	git pull origin master								pulls down any new changes
	git diff HEAD									to look what is different from our last commit, HEAD indicates our last commit
	git add octofamily/octodog.txt							
	git diff --staged								staged changes [creation of the new file according the the command above]	
	git reset octofamily/octodog.txt						unstage file
	git checkout --octocat.txt							undo all changes after the last commit
	git branch clean_up								create a branch called clean_up
	git checkout clean_up								checkout/switch to clean_up branch
	git rm '*.txt'									remove from disk the actual files & stage the removal of the files
	git commit -m "Remove all the cats"						perform rm above, committing the changes
	git checkout master								checkout/switch to master branch
	git merge clean_up								merge clean_up to master
	git branch -d clean_up								delete a branch after merge
	git push									push everything to remote repository


[https://git-scm.com/book/en/v2/Git-Basics-Getting-a-Git-Repository]

	[Initialization of a Repository in an Existing Directory]
	git init
	git add *.c
	git add LICENCE
	git commit -m 'initial project version'
	
	[Clone an Existing Repository]
	git clone https://github.com/libgit2/libgit2					[creates a directory named "libgit2"],
											[initializes a .git directory inside],
											[pulls down all the data for that repository],
											[checks out a working copy of the latest version].

	git clone https://github.com/libgit2/libgit2 libgit				[same as above & target directory is libgit]

	git status -s									[short status] 
	git status --short								[short status]

	cat .gitignore									[define a list of files, that will be ignored]

	




	[fabric basics]
	
	Definition: Library and command line tool for streamlining the use of SSH for application deployment or systems administration tasks.
		
		i.e.
		-A tool that lets you execute arbitrary python functions via the command line,
		-A library of subroutines to make executing shell commands over SSH easy and Pythonic
	
	

			SSH (Secure Shell):
			Secure Shell, or SSH is a cryptographic (encrypted) network protocol to allow remote login and other network sercives over an unsecured network.
			SSH provides a secure channel over an unsecured network in a client-server architecture, connecting an SSH client application with an SSH server.
			Common applications include remote command-line login and remote command line execution, but any network service can be secured with SSH.
			The protocol specification distinguishes between two major versions SSH-1 and SSH-2.
			The most visible application of the protocol is for access to shell accounts on Unix-like systems, but it sees some limited use on Windows as well.
			In 2015, Microsoft announced that they would include native support for SSH in a future release.
			SSH was designed as a replacement for Telnet and for unsecured remote shell protocols such as the Berkey rlogin, rsh, and rexec protocols.
			Those protocols send information, notably passwords, in plaintextm rendering them susceptible to interception and disclosure using packet analysis.
			The encription used by SSH is intented to provide confidentially and integrity of data over an unsecured network, such as the Internet, although
			files leaked by Edward Snowden indicate that National Security Agency can sometimes decrypt SSH, allowing them to read the content of SSH sessions. 



	def hello():
		print("Hello Word!")

	placed in a module file named fabfile.py in current working directory,
	that hello function can be executed with the fab tool 

	$fab hello
	Hello world!

	Note: the fab tool simply imports your fabfile and executes the function or functions you instruct it to.
	There is nothing magic about it - anything you can do in a normal python script can be done in a fabfile.
	
		[Task arguments]
		def hello(name="world"):
			print("Hello %s!" % name)

		$fab hello:name = Jeff
			Hello Jeff!

		Done.

		[Local Commands]
		As used above, fab only really saves a couple of lines of if __name__== "__main__"
		boilerplate. Its mostly designed for use with Fabrics API, which contains functions for executing shell commands,transferring files etc
		Let's build a hypothetical web application fabfile. This example scenario is as follows: The Web application is managed via Git on a 
		[remote host vchost]. On localhost, we have a local clone of said Web application. When we push changes back to vchost, we want to be 
		able to immediately install these changes on a remote host my_server in an automated fashion. We will do this by automoting the local and
		remote Git command. Fabfiles are usually work best at the root of a project:

		__init__.py
		app.wsgi
		fabfile.py
		manage.py
		my_app
			__init__.py
			models.py
			templates
				index.html
			tests.py
			urls.py
			views.py

		Note: We're using a Django application here, but only as an exaple, Fabric is not tied to any external codebase, save for its
		SSH library.
	
		[local shell command.]


			from fabric.api import local
			
			def prepare_deploy():
				local("./manage.py test my_app")
				local("git add -p && git commit")
				local("git push")

	


			[Alternative implementation:]
			
			from fabric.api import local
			
			def test():
				local("./manage.py test my_app")

			def commit():
				local("git add -p && git commit")

			def push():
				local("git push")

			def prepare_deploy():
				test()
				commit()
				push()
		

		[Failure]
		Our base case work fine now, but what happens if our tests fail? Chances are we want
		to put on the brakes and fix them before deploying.
		Fabric checks the return value of programs called via operations and will abort if they
		didn't exit cleanly. Let's see what happens if one of our tests encounters an error.
			[-> We do not have to do anything Fabric detected the failure and aborted, never running the commit task]

		
		[Failure handling]
		But what if we wanted to be flexable and give the user a choice? A setting or env var called warn_only
		lets you turn aborts into warnings, allowing flexible error handling to occur.

		Lets flip this setting on for our test function, and then inspect the result of the local call ourselves:
		
			from __future__ import with_statement
			from fabric.api import local, settings, abort
			from fabric.contrib.console import confirm
	
			def test():
				with settings(warn_only=True):
					result = local('./manage.py test my_app',capture = True)
				if result.failed and not confirm("Tests failed. Continue anyway?"):
					abort("Aborting at user request.")

			
			In adding this new feature we've introduced a number of new things:
				- The __future__ import required to use with: in Python 2.5
				- Fabric's contrib.console submodule, containing the confirm function, used for simple yes/no promts;
				- The setting context managerm used to apply settings to a specific block of code; 
				- Command-runnning operations like local can return objects containing info about their result (such as .failed or .rerun code)
				- And the abort function, used to manually abort execution		
	

		[Making Connections]
		Lets start wrapping up our fabfile by putting in the keystone: a deploy taks that is destined to run on one or more
		remote servers, and ensures the code is up to date.
		
			def deploy():
				code_dir = '/srv/django/myproject'
				with cd(code_dir):
					run("git pull")
					run("touch app.wsgi")

			
			Run is similar to local but runs remotely instead of locally.

			from __future__ import with_statement
			from fabric.api import local, settings, abort, run, cd
			from fabric.contrib.console import confirm

		We never specified any connection info in our fabfile, so Fabric doesn't know on which host(s) the remote command should be
		executed. When this happens, Fabric prompts us at runtime. 
		[Connection definitions use SSH-like "host strings" (e.g. user@host:port) and will use your username as default - so in this example
		, we just had to specify the hostname, my_server]	


		[Remote Interactivity]
		git pull works fine if you have already got a checkout of your souece code - but what if this is the first deploy.
		It would be nice to handle that case too and do the initial git clone:

		
			def deploy():
				code_dir = '/srv/django/myproject'
				with settings(warn_only = True):
					if run("test -d %s" % code_dir).failed:
						run("git clone user@vcshost:/path/to/repo/.git %s" % code_dir)
				with cd(code_dir):
					run("git pull")
					run("touch app.wsgi")


	
		As with our calls to local above, run also lets us construct clean python-level logic based on executed shell commands.
		However, the interesting part here is the git clone call: since we 're using Gits SSH method of accessing the 
		repository on our Git server, this means our remote run call will need to authenticate itself.

		Older versions of Fabric run remote programs in [limbo], unable to be touched from the local end. This is problematic when you have
		a serious need to enter passwords or otherwise interact with the remote program.

		Fabric 1.0 and later breaks down this wall and ensures you can always talk to the other side.
		Let's see what happens when we run our updated deploy task on a new server with no Git checkout:

		[Defining Connections Beforehand]
		Specifying connection info at runtime gets old real fast, so Fabric provides a handful of ways to do it in your fabfile
		or on the command line.
			[We won't cover all of them here, but we will show you the most common one: setting global host list, env.hosts]
			[env is a global dictionary-like object driving many of Fabric's settings, and can be written to with attributes as
			well (in fact, settings, seen above, is simply a wrapper for this.)]
			[Thus, we can modify it at module level near the top of our fabfile like so:]

				from __future__ import with_statement
				from fabric.api import *
				from fabric.contrib.console import confirm

				env.hosts = ['my_server']
	
				def test():
					do_test_stuff()

			When fab loads up ourfabfile, our modification of env will execute, storing our settings change. The end result is 
			exactly as above: our deploy task will run against the my_server server.

			This is also how you can tell Fabric to run on multiple remote systems at once: because enc.hosts is a list, fab
			iterates over it, calling the given task once for each connection.

		
		[Conclusion]
		#the code:

		from __future__ import with_statement
		from fabric.api import *
		from fabric.contrib.console import confirm
		
		env.hosts = ['my_server']

		def test():
			with setting(warn_only = True):
				result = local('./manage.py test my_app',capture = True)
			if result.failed and not confirm("Tests failed. Continue anyway?"):
				abort("Aborting at user request.")

		def commit():
			local("git add -p && git commit")

		def push():
			local("git push")

		def prepare_deploy():
			test()
			commit()
			push()

		def deploy():
			code_dir = '/srv/django/myproject'
			with settings(warn_only = True):
				if run("test -d %s" % code_dir).failed:
					run("git clone user@vcshost:/path/to/repo/.git %s" % code_dir)
			with cd(code_dir):
				run("git pull")
				run("touch app.wsgi")	
				

















	
		






























		

















	 
